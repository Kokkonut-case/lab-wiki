[
  {
    "objectID": "technical/MOGON/mogon.html",
    "href": "technical/MOGON/mogon.html",
    "title": "Useful Links",
    "section": "",
    "text": "Dummy text for now",
    "crumbs": [
      "Technical knowledge",
      "Using MOGON"
    ]
  },
  {
    "objectID": "technical/EGTsims/hawk-dove-reciprocator.html",
    "href": "technical/EGTsims/hawk-dove-reciprocator.html",
    "title": "Studying rock paper scissors using Python",
    "section": "",
    "text": "from sympy import *\nimport ternary\nimport numpy as np\nfrom ternary.helpers import project_point\n\ninit_printing()\n\nConsider a modification to the classic Hawk-Dove game that introduces a third strategy. A reciprocator, denoted by R, responds to a hawk with a hawk strategy, and responds to a dove with a dove strategy. When two reciprocators interact, the payoff to each is given by \\(V/2 - \\mu C\\). This value is obtained by simplifying \\(\\mu(V/2-C) + (1-\\mu)V/2\\), and thus, \\(\\mu\\) can be interpreted as the probability that a reciprocator will play a hawk strategy when it encounters another reciprocator.  We can first calculate the payoff matrix. Here, the order of the rows (and columns) is H-D-R.\n\nV,C,mu = symbols(' V C mu')\n\nPayoff_matrix = Matrix([[V/2 - C, V, V/2-C],[0,V/2,V/2],[V/2-C,V/2,V/2-mu*C]])\n\nPayoff_matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}- C + \\frac{V}{2} & V & - C + \\frac{V}{2}\\\\0 & \\frac{V}{2} & \\frac{V}{2}\\\\- C + \\frac{V}{2} & \\frac{V}{2} & - C \\mu + \\frac{V}{2}\\end{matrix}\\right]\\)\n\n\nAssuming that all strategies have a base fitness of \\(\\omega_0\\) and that the effect of the interactions is factored by a selection coefficient \\(s\\), we can obtain the fitness of each strategy:\n\n#Variables for fitness\nwh,wd,wr = symbols('omega_h omega_d omega_r')\n\n#Parameters affecting fitness\nw0,s,PD,PH = symbols('omega_0 s P_D P_H')\n\n#Variables for fitness differences\nalpha,beta = symbols('alpha beta')\n\nwh = w0 + s*(PH*(V/2 - C)+PD*(V) + (1-PD-PH)*(V/2 - C))\nwd = w0 + s*(PH*0 + PD*(V/2) + (1-PH-PD)*(V/2))\nwr = w0 + s*(PH*(V/2-C)+PD*(V/2)+(1-PH-PD)*(V/2-mu*C))\n\n\n#fitness of hawks\nwh\n\n\\(\\displaystyle \\omega_{0} + s \\left(P_{D} V + P_{H} \\left(- C + \\frac{V}{2}\\right) + \\left(- C + \\frac{V}{2}\\right) \\left(- P_{D} - P_{H} + 1\\right)\\right)\\)\n\n\n\n#fitness of doves\nwd\n\n\\(\\displaystyle \\omega_{0} + s \\left(\\frac{P_{D} V}{2} + \\frac{V \\left(- P_{D} - P_{H} + 1\\right)}{2}\\right)\\)\n\n\n\n#fitness of reciprocators\nwr\n\n\\(\\displaystyle \\omega_{0} + s \\left(\\frac{P_{D} V}{2} + P_{H} \\left(- C + \\frac{V}{2}\\right) + \\left(- C \\mu + \\frac{V}{2}\\right) \\left(- P_{D} - P_{H} + 1\\right)\\right)\\)\n\n\nWe can find the equations for nullclines - values at which two of the fitnesses are equal. Fixed points are given by the points at which all nullclines intersect.\n\nalpha = wh-wd\nbeta = wd-wr\n\nh_d_nullcline = solve([alpha],PH,PD)\nd_r_nullcline = solve([beta],PH,PD)\nh_r_nullcline = solve([alpha+beta],PH,PD)\n\n\nfixed_points = solve([alpha,beta],PH,PD)\n\nh_d_nullcline, d_r_nullcline, h_r_nullcline\n\n\\(\\displaystyle \\left( \\left\\{ P_{H} : \\frac{2 C}{V} + \\frac{P_{D} \\left(- 2 C - V\\right)}{V}\\right\\}, \\  \\left\\{ P_{H} : - \\frac{2 C P_{D} \\mu}{2 C \\mu - 2 C + V} + \\frac{2 C \\mu}{2 C \\mu - 2 C + V}\\right\\}, \\  \\left\\{ P_{H} : \\frac{P_{D} \\left(- 2 C \\mu + 2 C + V\\right)}{2 C \\mu - 2 C} + 1\\right\\}\\right)\\)\n\n\n\ndef h_d_null_func(pd,v,c,mu):\n    null_sol = lambdify([V,C,PD],h_d_nullcline[PH],'numpy')\n    ph = null_sol(v,c,pd)\n    pr = 1-pd-ph\n    \n    return (pd,pr,ph)\n\ndef d_r_null_func(pd,v,c,Mu):\n    null_sol = lambdify([V,C,PD,mu],d_r_nullcline[PH],'numpy')\n    ph = null_sol(v,c,pd,Mu)\n    pr = 1-pd-ph\n    \n    return (pd,pr,ph)\n\ndef h_r_null_func(pd,v,c,Mu):\n    null_sol = lambdify([V,C,PD,mu],h_r_nullcline[PH],'numpy')\n    ph = null_sol(v,c,pd,Mu)\n    pr = 1-pd-ph\n    \n    return (pd,pr,ph)\n\n\n#Analytical solution for fixed points\nfixed_points\n\n\\(\\displaystyle \\left\\{ P_{D} : \\frac{4 C^{2} \\mu - 4 C^{2} - 2 C V \\mu + 2 C V}{4 C^{2} \\mu - 4 C^{2} + V^{2}}, \\  P_{H} : \\frac{2 C V \\mu}{4 C^{2} \\mu - 4 C^{2} + V^{2}}\\right\\}\\)\n\n\nWe can find fixed points by plotting these nullclines on a simplex and looking at points of intersection: i.e plotting nullclines under the constraint that all are positive and that \\(P_H + P_D + P_R \\leq 1\\)\n\ndef within_simplex(r): #Find out whether a given point lies within the S_1 simplex\n    if r[0]+r[1]+r[2] &lt;= 1 and r[0] &gt;= 0 and r[1] &gt;= 0 and r[2] &gt;= 0:\n        return True\n    else:\n        return False\n    \n#Convert the nullclines into Python functions\nwd_func = lambdify([PD,PH,V,w0,s],wd)\nwh_func = lambdify([PD,PH,V,C,w0,s],wh)\nwr_func = lambdify([PD,PH,V,C,mu,w0,s],wr)\n\n#Get the vector describing the trajectory at each point\n#Trajectory is given by the replicator equation df/dt = (w-w_bar)f\ndef get_vector(pd,ph,v,c,mu,w0,s):\n    \n    #get the fitness values\n    wd_val = wd_func(pd,ph,v,w0,s)\n    wh_val = wh_func(pd,ph,v,c,w0,s)\n    wr_val = wr_func(pd,ph,v,c,mu,w0,s)\n    \n    #Get relative fitness\n    w_bar = pd*wd_val + ph*wh_val + (1-pd-ph)*wr_val\n    wd_val -= w_bar\n    wh_val -= w_bar\n    wr_val -= w_bar\n    \n    #Project the 3D Cartesian coordinates onto a 2D simplex\n    r_proj = project_point((pd,1-pd-ph,ph))\n    dr_proj = project_point((pd*wd_val,(1-pd-ph)*wr_val,ph*wh_val))\n    \n    return r_proj,dr_proj\n\ndef get_color(pd,ph,v,c,mu,w0,s): #To indicate which strategy is best at that point\n    \n    wd = wd_func(pd,ph,v,w0,s)\n    wh = wh_func(pd,ph,v,c,w0,s)\n    wr = wr_func(pd,ph,v,c,mu,w0,s)\n    \n    if wd &gt;= wh and wd &gt;= wr:\n        return 'red'\n    if wh &gt;= wd and wh &gt;= wr:\n        return 'green'\n    if wr &gt;= wh and wr &gt;= wd:\n        return 'blue'\n    else:\n        return 'black'   \n\n\ndef make_ternary_plot(V,C,mu,w0=0,s=1,plot_field=True,plot_nullclines=True,save=False,filename=''):\n    \n    figure, tax = ternary.figure(scale=1)\n\n    fontsize = 16\n    offset = 0.11\n    \n    #set background\n    tax.set_background_color(color=\"#bbbbbb\", alpha=0.7)\n    \n    # Draw Boundary and Gridlines\n    tax.boundary(linewidth=2.0)\n    tax.gridlines(color=\"#aaaaaa\", linestyle='-',linewidth=1, multiple=1)\n    tax.gridlines(color=\"#aaaaaa\", linestyle='-',linewidth=0.5, multiple=0.2,alpha=0.5)\n    \n    #Depict parameter values\n    tax.set_title(\"V = \"+ str(V) + \"\\nC = \" + str(C) + \"\\n$\\mu$ = \" + str(mu) + '\\nV/2C = ' + format(V/(2*C),'.2f'),position=(-0.05,1.5,-0.03),fontsize=18)\n\n    #Label the axes and vertices\n    tax.top_corner_label(\"Pure Reciprocator\", fontsize=fontsize,position=(-0.1,1.2,-0.03),offset=0)\n    tax.left_corner_label(\"Pure\\nHawk\", fontsize=fontsize,position=(-0.05,-0.01,1.1),offset=0)\n    tax.right_corner_label(\"Pure\\nDove\", fontsize=fontsize,position=(1.05,0,-0.02),offset=0)\n    tax.left_axis_label(\"$P_H$\", fontsize=18, offset=0.16)\n    tax.right_axis_label(\"$P_R$\", fontsize=18, offset=0.16)\n    tax.bottom_axis_label(\"$P_D$\", fontsize=18, offset=0.16)\n    \n    if plot_nullclines:\n        \n        pd_list = np.arange(0,1.01,0.01)\n        h_d_null = []\n        h_r_null = []\n        d_r_null = []\n        for pd in pd_list:\n        \n            #Get the value of the H-D null\n            tuple1 = h_d_null_func(pd,V,C,mu)\n            if within_simplex(tuple1):\n                h_d_null.append(tuple1)\n        \n            #Get the value of the H-R null\n            tuple2 = h_r_null_func(pd,V,C,mu)\n            if within_simplex(tuple2):\n                h_r_null.append(tuple2)\n        \n            #Get the value of the D-R null\n            tuple3 = d_r_null_func(pd,V,C,mu)\n            if within_simplex(tuple3):\n                d_r_null.append(tuple3)\n    \n        #Plot nullclines\n        if len(h_d_null) &gt; 0:\n            tax.plot(h_d_null,linewidth=2.0,color='green',label='H-D nullcline')\n        if len(h_r_null) &gt; 0:\n            tax.plot(h_r_null,linewidth=2.0,color='#0047ab',label='R-H nullcline')\n        if len(d_r_null) &gt; 0:\n            tax.plot(d_r_null,linewidth=2.0,color='orange',label='D-R nullcline')\n    \n    #draw the vector field\n    if plot_field:\n        length = 0.02\n        prop_list = np.arange(0,1.2,0.05)\n        for pd in prop_list:\n            for ph in prop_list:\n                if within_simplex((pd,ph,1-pd-ph)):\n                    r, dr = get_vector(pd,ph,V,C,mu,w0,s)\n                    if np.hypot(dr[0],dr[1]) != 0:\n                        dx,dy = length*dr/np.hypot(dr[0],dr[1])\n                    else:\n                        dx,dy = 0,0\n                    color = get_color(pd,ph,V,C,mu,w0,s)\n                    tax.get_axes().quiver(r[0],r[1],dx,dy,color=color,width=0.005,scale=0.1,scale_units='inches')\n    \n    tax.ticks(axis='lbr', fontsize=13, multiple=0.2, linewidth=0.5, tick_formats=\"%.1f\",axes_colors={'l':'white','r':'white','b':'white'}, offset=0.02)    \n    tax.get_axes().axis('off')\n    tax.clear_matplotlib_ticks()\n    tax.legend()\n    \n    if save:\n        tax.savefig(str(filename+\".png\"))\n    tax.show()\n\n&lt;&gt;:17: SyntaxWarning: invalid escape sequence '\\m'\n&lt;&gt;:17: SyntaxWarning: invalid escape sequence '\\m'\n/var/folders/b_/xqbznk296tb4z4dhdrlrd4rr0000gn/T/ipykernel_6419/3399975650.py:17: SyntaxWarning: invalid escape sequence '\\m'\n  tax.set_title(\"V = \"+ str(V) + \"\\nC = \" + str(C) + \"\\n$\\mu$ = \" + str(mu) + '\\nV/2C = ' + format(V/(2*C),'.2f'),position=(-0.05,1.5,-0.03),fontsize=18)\n\n\n\nmake_ternary_plot(20,8,0.2,save=False)",
    "crumbs": [
      "Technical knowledge",
      "Evolutionary game theory examples",
      "Hawk dove reciprocator"
    ]
  },
  {
    "objectID": "links.html",
    "href": "links.html",
    "title": "Useful Links",
    "section": "",
    "text": "ggplot2 cheatsheet\nFundamentals of Data Visualization\nA collection of graphs made in R\nA collection of graphs made in Python\nA color scheme generator for making better plots: Generates complimentary colors, lets you vary hue, provides simulations of various types of colorblindness as well as common lightness/hue/saturation changes that can be caused by faulty screens.",
    "crumbs": [
      "Useful links"
    ]
  },
  {
    "objectID": "links.html#data-visualization",
    "href": "links.html#data-visualization",
    "title": "Useful Links",
    "section": "",
    "text": "ggplot2 cheatsheet\nFundamentals of Data Visualization\nA collection of graphs made in R\nA collection of graphs made in Python\nA color scheme generator for making better plots: Generates complimentary colors, lets you vary hue, provides simulations of various types of colorblindness as well as common lightness/hue/saturation changes that can be caused by faulty screens.",
    "crumbs": [
      "Useful links"
    ]
  },
  {
    "objectID": "links.html#coding",
    "href": "links.html#coding",
    "title": "Useful Links",
    "section": "Coding",
    "text": "Coding\n\nThe good research coding handbook\nPro git, an introduction to using git and GitHub for version control\nThe tidyverse, a set of packages for data wrangling and data visualization in R\n\nUsing the tidyverse for data wrangling in R\nHands-on tutorial on using dplyr for data wrangling in R\nA mapping of MATLAB functions to numpy functions in Python\npython-ternary, a library for making ternary plots in Python using matplotlib\nHigh-performance computing using SLURM:\n\nIntroduction to SLURM and job scripting\nCreating batch scripts for SLURM\nSLURM tutorial series by the makers themselves\nSLURM directives to put into a bash script\nUsing Python on the HPC\n\nGenerally useful fact: You can push your local git repo to two or more remote locations simultaneously. To set this up, we need to run the following locally on the terminal:\n\n\n\nTerminal\n\ngit remote set-url origin --push --add &lt;a remote&gt;\ngit remote set-url origin --push --add &lt;another remote&gt;",
    "crumbs": [
      "Useful links"
    ]
  },
  {
    "objectID": "links.html#reading-writing-and-presentation",
    "href": "links.html#reading-writing-and-presentation",
    "title": "Useful Links",
    "section": "Reading, writing, and presentation",
    "text": "Reading, writing, and presentation\n\nPlaylist on academic writing by the Leadership Lab at UChicago\nHow to speak by Patrick Winston at MIT\nList of commonly used phrases in academic writing\nTen simple rules for making good oral presentations\nHow to give a theory talk by Shengwu Li",
    "crumbs": [
      "Useful links"
    ]
  },
  {
    "objectID": "homepage.html#kokkonuts-wiki",
    "href": "homepage.html#kokkonuts-wiki",
    "title": "Kokkonuts wiki homepage",
    "section": "Kokkonuts wiki",
    "text": "Kokkonuts wiki\nThe purpose of this wiki is to collate useful information and technical knowledge. For now, I (shikhara) am just porting some notebooks I already had. Will hopefully flesh out the wiki later.\nTo go back to the kokkonutscase repository of scripts, click here.  To visit the kokkonuts lab group webpage, click here.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "technical/math_notebooks/NLD.html",
    "href": "technical/math_notebooks/NLD.html",
    "title": "Studying one-dimensional and two-dimensional systems",
    "section": "",
    "text": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\nfrom sympy import *",
    "crumbs": [
      "Technical knowledge",
      "General math",
      "Nonlinear dynamics"
    ]
  },
  {
    "objectID": "technical/math_notebooks/NLD.html#one-dimensional-systems",
    "href": "technical/math_notebooks/NLD.html#one-dimensional-systems",
    "title": "Studying one-dimensional and two-dimensional systems",
    "section": "One dimensional systems",
    "text": "One dimensional systems\nSuch systems are characterized by equations of the form  \\[\n\\dot{x} = f(x)\n\\]  As an example, I’ll use the equation \\(\\dot{x} = rx-x^3\\) for all analyses below\n\ndef xdot(x,t,r):\n    return r*x - x**3\n    \n\n\nSimple plotting to find fixed points\nTo start with, we can plot \\(\\dot{x}\\) vs \\(x\\). The points at which this curve intersects the x-axis represent fixed points, i.e points where \\(\\dot{x} = 0\\). A system starting at a fixed point never leaves it. Further, every trajectory in a one dimensional system either approaches a fixed point or diverges to infinity.\n\ndef xdot_vs_x(rlist):\n    for r in np.arange(rlist[0],rlist[1],rlist[2]):\n        x = np.arange(-10,10,0.01)\n        xdotlist = []\n        for val in x:\n            xdotlist.append(xdot(val,0,r))\n        \n        plt.plot(x,xdotlist,label='r = '+str(r))\n    plt.axhline(y=0,color='g',linestyle='--')\n    plt.axvline(x=0,color='g',linestyle='--')\n    plt.legend(loc='upper right')\n    plt.xlabel('x')\n    plt.ylabel('x dot')\n    plt.xlim([-5,5])\n    plt.ylim([-10,10])\n    plt.show()\n\n\nxdot_vs_x([-6,6.1,6])\n\n\n\n\n\n\n\n\nAs we can see, this system appears to show three fixed points for r &gt; 0, and a single fixed point at x = 0 for r \\(\\leq\\) 0.\n\n\nActually solving the ODE to find fixed points\n\nObtaining an analytic solution\nThis can also be seen by actually solving the differential equation. I will use sympy to analytically solve the differential equation\n\n#Solving the given ODE symbolically\nn,r = symbols('n r')\ninit_printing()\nn_dot = r*n - n**3\n\nsolve(n_dot,n)\n\n\\(\\displaystyle \\left[ 0, \\  - \\sqrt{r}, \\  \\sqrt{r}\\right]\\)\n\n\n\n\nNumeric integration to find trajectories\nSince solving ODEs analytically is not always feasible, we could also use numerical integration to obtain the trajectory, i.e the values of \\(x(t)\\) as \\(t\\) varies, given an initial value \\(x_0\\). Here, I use the odeint package from scipy.\n\ndef trajectory(rlist,x0,t=10,tstep=0.01):\n    xlist = np.arange(0,t,tstep)\n    for r in rlist:\n        ylist = odeint(func=xdot,y0=[x0],t=np.arange(0,t,tstep),args=tuple([r]))\n        plt.plot(xlist,ylist,label='r = '+str(r))\n    \n    plt.legend(loc='upper right')\n    plt.xlabel('time')\n    plt.ylabel('x')\n    plt.show()\n\n\ntrajectory(np.arange(-4,4.1,4),1)\n\n\n\n\n\n\n\n\n\n\n\nDependence on parameters\nFinally, we can examine how the number of fixed points varies as we vary parameters. In our case, the system has a single parameter: \\(r\\).   We examine the relationship between fixed points and parameter values by plotting a bifurcation diagram. In this case, we plot \\(r\\) against the corresponding equilibrium values of \\(x\\), for various initial values \\(x(0)\\).\n\ndef bifurcation(r_range):\n    rvals = np.arange(r_range[0],r_range[1],r_range[2])\n    eq_list = []\n    r_list = []\n    for r in rvals:\n        for x in np.arange(-10,10.1,5):\n            unique_sols = np.unique(odeint(func=xdot,y0=[x],t=np.arange(0,1000,1),args=tuple([r]))[900:1000])\n            for sol in unique_sols:\n                eq_list.append(sol)\n                r_list.append(r)\n    \n    plt.scatter(r_list,eq_list,color='g',s=2)\n    plt.xlabel('r')\n    plt.ylabel('x*')\n    plt.show()\n        \n\n\nbifurcation([-4,4.1,0.1])\n\n\n\n\n\n\n\n\nThis diagram tells us that when r is less than 0, there is a single fixed point present at x = 0. At r = 0, the behaviour changes, and two new fixed points appear for all values of r &gt; 0. Values of \\(r\\) at which such changes occur are known as bifurcation points.",
    "crumbs": [
      "Technical knowledge",
      "General math",
      "Nonlinear dynamics"
    ]
  },
  {
    "objectID": "technical/math_notebooks/NLD.html#two-dimensional-systems",
    "href": "technical/math_notebooks/NLD.html#two-dimensional-systems",
    "title": "Studying one-dimensional and two-dimensional systems",
    "section": "Two dimensional systems",
    "text": "Two dimensional systems\nTwo dimensional systems are systems of the form:\n\\[\n\\begin{align*}\n\\dot{x} = f(x,y) \\\\\n\\dot{y} = g(x,y)\n\\end{align*}\n\\] \nAs before, we can begin by plotting the phase portrait. Here, the phase portrait is two-dimensional, and you can think of \\(f(x,y)\\) and \\(g(x,y)\\) as representing the flow on a plane.\n\ndef twoD_phase_portrait(var,var_dot,xlims=[-10,10,40],ylims=[-10,10,40],plot_nullclines=True,save=False,filename='2D_portrait.png'):    \n    \n    #convert the symbolic math into a python function\n    dvar = lambdify(var,var_dot,'numpy')\n    \n    #The range of values in which you want the phase portrait\n    x_in = np.linspace(xlims[0],xlims[1],xlims[2])\n    y_in = np.linspace(ylims[0],ylims[1],ylims[2])\n        \n    X_in, Y_in = np.meshgrid(x_in,y_in)\n    \n    #Compute and store the derivatives at each point\n    u,v = np.zeros(X_in.shape), np.zeros(Y_in.shape)\n    shape_1, shape_2 = X_in.shape\n    for i in range(shape_1):\n        for j in range(shape_2):\n            pt_x = X_in[i,j]\n            pt_y = Y_in[i,j]\n            derivative = dvar(pt_x,pt_y)\n            u[i,j] = derivative[0]\n            v[i,j] = derivative[1]\n    \n    colors = np.hypot(u,v)\n    colors[colors==0] = 1 #To avoid division by 0\n    \n    #Normalize arrow lengths\n    #u /= colors\n    #v /= colors\n    \n    \n    plt.figure(figsize=(8,8))\n    plt.quiver(X_in,Y_in,u,v,colors,cmap='viridis',pivot='mid')\n    \n    if plot_nullclines:\n        #Compute and plot the nullclines\n        x_nullcline = solve(var_dot[0])\n        y_nullcline = solve(var_dot[1])\n    \n        xnull_label = \"x nullcline\"\n        for sol in range(len(x_nullcline)):\n            try:\n                null_func = lambdify(var[1],x_nullcline[sol][x],'numpy')\n                null = []\n                for i in range(len(y_in)):\n                    null.append(null_func(y_in[i]))\n                plt.plot(null,y_in,'b',label=xnull_label)\n                xnull_label = '_nolegend_' #To avoid duplicate labels\n            except KeyError:\n                null_func = lambdify(var[0],y_nullcline[sol][y],'numpy')\n                null = []\n                for i in range(len(x_in)):\n                    null.append(null_func(x_in[i]))\n                plt.plot(x_in,null,'b',label=xnull_label)\n                xnull_label = '_nolegend_' #To avoid duplicate labels\n    \n        ynull_label = 'y nullcline'\n        for sol in range(len(y_nullcline)):\n            try:\n                null_func = lambdify(var[1],y_nullcline[sol][x],'numpy')\n                null = []\n                for i in range(len(y_in)):\n                    null.append(null_func(y_in[i]))\n                plt.plot(null,y_in,'r',label=ynull_label)\n                ynull_label = '_nolegend_' #To avoid duplicate labels\n            except KeyError:\n                null_func = lambdify(var[0],y_nullcline[sol][y],'numpy')\n                null = []\n                for i in range(len(x_in)):\n                    null.append(null_func(x_in[i]))\n                plt.plot(x_in,null,'r',label=ynull_label)\n                ynull_label = '_nolegend_' #To avoid duplicate labels\n    \n    plt.xlabel(str(var[0]))\n    plt.ylabel(str(var[1]))\n    plt.xlim(xlims[0:2])\n    plt.ylim(ylims[0:2])\n    plt.colorbar(label=\"Derivative\")\n    \n    if plot_nullclines:\n        plt.legend(bbox_to_anchor=[1.3,1])\n    if save:\n        plt.savefig(filename)\n    \n\n\nx,y = symbols('x y')\n\ninit_printing()\n\n\n#write the differential equations here\nx_dot, y_dot = cos(x-y), sin(x*y+1)\n\nx_dot, y_dot\n\n\\(\\displaystyle \\left( \\cos{\\left(x - y \\right)}, \\  \\sin{\\left(x y + 1 \\right)}\\right)\\)\n\n\n\ntwoD_phase_portrait([x,y],[x_dot,y_dot],xlims=[-10,10,100],ylims=[-10,10,100],plot_nullclines=False)\n\n\n\n\n\n\n\n\n\nNullclines\nOne useful notion is that of a nullcline. Nullclines are defined as the curves where either \\(\\dot{x} = 0\\) or \\(\\dot{y} = 0\\). Fixed points are points at which nullclines intersect.\n\ntwoD_phase_portrait([x,y],[x_dot,y_dot],xlims=[-10,10,100],ylims=[-10,10,100])\n\n\n\n\n\n\n\n\n\n#Number of fixed points should equal the number of times the nullclines intersect\nfixed_points = solve([x_dot,y_dot],[x,y])\nlen(fixed_points)\n\n\\(\\displaystyle 8\\)",
    "crumbs": [
      "Technical knowledge",
      "General math",
      "Nonlinear dynamics"
    ]
  },
  {
    "objectID": "technical/EGTsims/RPS.html",
    "href": "technical/EGTsims/RPS.html",
    "title": "Studying rock paper scissors using Python",
    "section": "",
    "text": "import ternary\nimport numpy as np\nimport matplotlib.patches as mpatches\nfrom ternary.helpers import project_point\nfrom matplotlib.legend_handler import HandlerPatch\nfrom sympy import *\n\ninit_printing()",
    "crumbs": [
      "Technical knowledge",
      "Evolutionary game theory examples",
      "Rock paper scissors"
    ]
  },
  {
    "objectID": "technical/EGTsims/RPS.html#case-1-v-c",
    "href": "technical/EGTsims/RPS.html#case-1-v-c",
    "title": "Studying rock paper scissors using Python",
    "section": "Case 1: V > C",
    "text": "Case 1: V &gt; C\n\n# Note that I'm not plotting nullclines here.\n\nmake_ternary_plot(10,0)\n\n\n\n\n\n\n\n\nWhen V &gt; C, the interior fixed point is an attractor. Trajectories that are not on the edges flow into the fixed point.",
    "crumbs": [
      "Technical knowledge",
      "Evolutionary game theory examples",
      "Rock paper scissors"
    ]
  },
  {
    "objectID": "technical/EGTsims/RPS.html#case-2-v-c",
    "href": "technical/EGTsims/RPS.html#case-2-v-c",
    "title": "Studying rock paper scissors using Python",
    "section": "Case 2: V = C",
    "text": "Case 2: V = C\n\nmake_ternary_plot(10,10)\n\n\n\n\n\n\n\n\nWhen V=C, the game is ‘zero-sum’. Here, the internal fixed point is neither an attractor nor a repeller. Trajectories form closed orbits which circle the fixed point.",
    "crumbs": [
      "Technical knowledge",
      "Evolutionary game theory examples",
      "Rock paper scissors"
    ]
  },
  {
    "objectID": "technical/EGTsims/RPS.html#case-3-v-c",
    "href": "technical/EGTsims/RPS.html#case-3-v-c",
    "title": "Studying rock paper scissors using Python",
    "section": "Case 3: V < C",
    "text": "Case 3: V &lt; C\n\nmake_ternary_plot(0,10)\n\n\n\n\n\n\n\n\nWhen V &lt; C, the internal fixed point is unstable. Trajectories move away from the center and go towards the edges of the simplex. In both computer simulations and real populations, this generally means that one of the strategies will go extinct, even though theoretically, the edges are never reached.",
    "crumbs": [
      "Technical knowledge",
      "Evolutionary game theory examples",
      "Rock paper scissors"
    ]
  }
]